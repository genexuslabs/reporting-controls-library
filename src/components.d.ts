/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { QueryRequest } from "./components/gx-query/query-chat/query-chat";
import { GeneratorType, GxQueryItem, QueryViewerBase, QueryViewerChartType, QueryViewerContinent, QueryViewerCountry, QueryViewerMapType, QueryViewerOrientation, QueryViewerOutputType, QueryViewerPlotSeries, QueryViewerRegion, QueryViewerShowDataAs, QueryViewerShowDataLabelsIn, QueryViewerTotal, QueryViewerTranslations, QueryViewerTrendPeriod, QueryViewerXAxisLabels } from "@genexus/reporting-api/dist/types/basic-types";
import { GxQueryItem as GxQueryItem1, QueryViewerChartType as QueryViewerChartType1, QueryViewerOrientation as QueryViewerOrientation1, QueryViewerPlotSeries as QueryViewerPlotSeries1, QueryViewerShowDataAs as QueryViewerShowDataAs1, QueryViewerSliderRange, QueryViewerTranslations as QueryViewerTranslations1, QueryViewerTrendPeriod as QueryViewerTrendPeriod1, QueryViewerXAxisLabels as QueryViewerXAxisLabels1, TrendIcon } from "./common/basic-types";
import { QueryViewerServiceData, QueryViewerServiceMetaData, QueryViewerServiceResponse } from "@genexus/reporting-api/dist/types/service-result";
import { Axis, ChartOptions, LegendOptions, PaneOptions, PlotOptions, SeriesLineOptions, SeriesOptionsType, SubtitleOptions, TitleOptions, TooltipOptions, XAxisOptions, YAxisOptions } from "highcharts";
import { QueryViewerParameterChangedEvent } from "./components/query-viewer-parameter/query-viewer-parameter";
export namespace Components {
    interface GxFloatingWindow {
        /**
          * Width of expanded window. Default 300px
         */
        "expandedSize": "300px";
        /**
          * Determines if the menu is minimized
         */
        "isMinimized": boolean;
        /**
          * Determines if the menu is unlocked
         */
        "isUnlocked": boolean;
        /**
          * This property specifies the items of the chat.
         */
        "mainTitle": string;
        /**
          * Determines if the menu can be unlocked or minimize
         */
        "resizeWindow": boolean;
    }
    interface GxQueryChat {
        /**
          * Clean chat
         */
        "gxCleanChat": () => Promise<void>;
        /**
          * Specify the size of the icon messages. ex 50px
         */
        "messageIconSize": string;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName": "";
        /**
          * Text that appears in the input control when it has no value set
         */
        "placeholder": string;
    }
    interface GxQueryMenu {
        /**
          * Specifies a short string, typically 1 to 3 words, that authors associate with an element to provide users of assistive technologies with a label for the element.
         */
        "accessibleName": "Query list";
        /**
          * Base URL of the server
         */
        "baseUrl": string;
        /**
          * Show queries items group by month
         */
        "groupItemsByMonth": true;
        /**
          * Add a new query item
          * @param item GxQueryItem
         */
        "gxAddQuery": (item: GxQueryItem) => Promise<void>;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName": string;
        /**
          * Dates to group queries
         */
        "rangeOfDays": { days: number; label: string }[];
        /**
          * Use this property to pass a query obtained from GXquery. This disabled the call to GxQuery API:    Id: string;    Name: string;    Description: string;    Expression: string;    Modified: string;
         */
        "serializedObject": string;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery": true;
    }
    interface GxQueryMenuItem {
        /**
          * Toggle edit mode
         */
        "editMode": boolean;
        /**
          * Id of item active
         */
        "isActive": boolean;
        /**
          * This property specify the title of the item.
         */
        "item": GxQueryItem1;
        "setFocus": () => Promise<void>;
    }
    interface GxQueryRender {
        /**
          * Base URL of the server
         */
        "baseUrl": string;
        /**
          * Data for query viewer
         */
        "data": QueryViewerServiceData | string;
        /**
          * Environment of the project: java or net
         */
        "environment": GeneratorType;
        "fetchingDataLabel": "Fetching data";
        /**
          * Metadata for query viewer
         */
        "metadata": QueryViewerServiceMetaData | string;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName": string;
        "noDataLabel": "No Data";
        /**
          * Provide the Query properties
         */
        "query": QueryViewerBase;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery": true;
    }
    interface GxQueryViewer {
        /**
          * Allowing elements order to change
         */
        "allowElementsOrderChange": boolean;
        /**
          * Allow selection
         */
        "allowSelection": boolean;
        /**
          * Auto refresh group
         */
        "autoRefreshGroup": string;
        /**
          * If type== PivotTable or Table, if true will shrink the table
         */
        "autoResize": boolean;
        /**
          * If autoResize, in here select the type, Width, height, or both
         */
        "autoResizeType": "Both" | "Vertical" | "Horizontal";
        /**
          * If type == Chart, this is the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType": QueryViewerChartType;
        /**
          * If type == Map and region = Continent, this is the continent to display in the map
         */
        "continent": QueryViewerContinent;
        /**
          * If type == Map and region = Country, this is the country to display in the map
         */
        "country": QueryViewerCountry;
        /**
          * A CSS class to set as the `gx-query-viewer` element class.
         */
        "cssClass": string;
        /**
          * Version of data
         */
        "dataVersionId": number;
        /**
          * Allowing or not Column sort
         */
        "disableColumnSort": boolean;
        /**
          * If type== PivotTable or Table allow to export to HTML
         */
        "exportToHTML": boolean;
        /**
          * If type== PivotTable or Table allow to export to PDF
         */
        "exportToPDF": boolean;
        /**
          * If type== PivotTable or Table allow to export to XLS
         */
        "exportToXLS": boolean;
        /**
          * If type== PivotTable or Table allow to export to XLSX
         */
        "exportToXLSX": boolean;
        /**
          * If type== PivotTable or Table allow to export to XML
         */
        "exportToXML": boolean;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin": boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline": boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend": boolean;
        /**
          * Language of the QueryViewer
         */
        "language": string;
        /**
          * If type == Map, this is the map type: Choropleth or Bubble
         */
        "mapType": QueryViewerMapType;
        /**
          * Object of QueryViewer
         */
        "object": string;
        /**
          * Object type -> Query or DataProvider
         */
        "objectType": string;
        /**
          * Orientation of the graph
         */
        "orientation": QueryViewerOrientation;
        /**
          * If paging true, number of items for a single page
         */
        "pageSize": number;
        /**
          * If type == PivotTable or Table, if true there is paging, else everything in one table
         */
        "paging": boolean;
        /**
          * Timeline
         */
        "plotSeries": QueryViewerPlotSeries;
        /**
          * Title of the QueryViewer
         */
        "queryTitle": string;
        /**
          * If type == Map, this is the region to display in the map
         */
        "region": QueryViewerRegion;
        /**
          * For timeline for remembering layout
         */
        "rememberLayout": boolean;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse": QueryViewerServiceResponse;
        /**
          * Specifies whether to show the actual values, the values as a percentage of the target values, or both.
         */
        "showDataAs": QueryViewerShowDataAs;
        /**
          * Ax to show data labels
         */
        "showDataLabelsIn": QueryViewerShowDataLabelsIn;
        /**
          * if true show values on the graph
         */
        "showValues": boolean;
        /**
          * Theme for showing the graph
         */
        "theme": string;
        /**
          * True if grand total is shown for all table columns
         */
        "totalForColumns": QueryViewerTotal;
        /**
          * True if grand total is shown for all table rows
         */
        "totalForRows": QueryViewerTotal;
        /**
          * For translate the labels of the outputs
         */
        "translations": QueryViewerTranslations;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod": QueryViewerTrendPeriod;
        /**
          * Type of the QueryViewer: Table, PivotTable, Chart, Card
         */
        "type": QueryViewerOutputType;
        /**
          * if true the x Axes intersect at zero
         */
        "xAxisIntersectionAtZero": boolean;
        /**
          * Labels for XAxis
         */
        "xAxisLabels": QueryViewerXAxisLabels;
        /**
          * X Axis title
         */
        "xAxisTitle": string;
        /**
          * Y Axis title
         */
        "yAxisTitle": string;
    }
    interface GxQueryViewerCard {
        /**
          * Describe the content or purpose of the element set as Datum in the query object.
         */
        "description": string;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin": boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline": boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend": boolean;
        /**
          * Specifies the maximum value in the series.
         */
        "maxValue": string;
        /**
          * Specifies the minimum value in the series.
         */
        "minValue": string;
        /**
          * Specifies the data used for the series of the sparkline.
         */
        "seriesData": number[][];
        /**
          * For translate the labels of the outputs
         */
        "translations": QueryViewerTranslations1;
        /**
          * Specifies the icon used for the trend.
         */
        "trendIcon": TrendIcon;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod": QueryViewerTrendPeriod1;
        /**
          * Specifies the value to show in the card.
         */
        "value": string;
    }
    interface GxQueryViewerCardController {
        /**
          * A CSS class to set as the `gx-query-viewer-card-controller` element class.
         */
        "cssClass": string;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin": boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline": boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend": boolean;
        /**
          * Specifies whether to arrange the attributes horizontally or vertically when than one data attribute is present.
         */
        "orientation": QueryViewerOrientation1;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse": QueryViewerServiceResponse;
        /**
          * Specifies whether to show the actual values, the values as a percentage of the target values, or both.
         */
        "showDataAs": QueryViewerShowDataAs1;
        /**
          * For translate the labels of the outputs
         */
        "translations": QueryViewerTranslations1;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod": QueryViewerTrendPeriod1;
    }
    interface GxQueryViewerChart {
        /**
          * get the current extremes for the axis.
         */
        "addSeries": (series: SeriesLineOptions) => Promise<Highcharts.Series>;
        /**
          * Title that will be displayed on top of the query
         */
        "chartOptions": ChartOptions;
        /**
          * Name of the element
         */
        "chartTitle": TitleOptions;
        /**
          * Option of the chartType used to visualize and represent data.
         */
        "chartType": QueryViewerChartType1;
        /**
          * get the current extremes for the axis.
         */
        "getExtremes": () => Promise<Highcharts.ExtremesObject>;
        /**
          * Options of the tooltip, the tooltip appears when hovering over a point in a series.
         */
        "legendOptions": LegendOptions;
        /**
          * Options of the chart.
         */
        "paneOptions": PaneOptions;
        /**
          * Options of the legend, the legend displays the series in a chart with a predefined symbol and the name of the series.
         */
        "plotOptions": PlotOptions;
        /**
          * Specifies if the chart series are plotted together in the same chart or alone in separate charts.
         */
        "plotSeries": QueryViewerPlotSeries1;
        /**
          * Options of the X axis (usually this is the horizontal axis).
         */
        "seriesOptions": SeriesOptionsType[];
        /**
          * set the current extremes for the axis.
         */
        "setExtremes": (minDate: number, maxDate: number, redraw: boolean) => Promise<void>;
        /**
          * Specifies whether the values for the data elements are shown in the chart or not.
         */
        "showValues": boolean;
        /**
          * Name of the element
         */
        "subtitleOptions": SubtitleOptions;
        /**
          * Options of the chart.
         */
        "tooltipOptions": TooltipOptions;
        /**
          * For translate the labels of the outputs
         */
        "translations": QueryViewerTranslations1;
        /**
          * Specifies whether the X axis intersects the Y axis at zero or the intersection point is automatically calculated.
         */
        "xAxisIntersectionAtZero": boolean;
        /**
          * Specifies if the labels in the X axis of a chart are shown horizontally or vertically.
         */
        "xAxisLabels": QueryViewerXAxisLabels1;
        /**
          * X axis title, if specified.
         */
        "xAxisTitle": string;
        /**
          * Options of the Y axis (usually this is the vertical axis).
         */
        "xaxisOptions": XAxisOptions | XAxisOptions[];
        /**
          * Y axis title, if specified.
         */
        "yAxisTitle": string;
        /**
          * Options of the plot for each series type chart.
         */
        "yaxisOptions": YAxisOptions | YAxisOptions[];
        /**
          * zoom out for the chart
         */
        "zoomOut": () => Promise<void>;
    }
    interface GxQueryViewerChartController {
        /**
          * Allow selection
         */
        "allowSelection": boolean;
        /**
          * If type == Chart, this is the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType": QueryViewerChartType1;
        /**
          * A CSS class to set as the `gx-query-viewer-chart-controller` element class.
         */
        "cssClass": string;
        /**
          * Timeline
         */
        "plotSeries": QueryViewerPlotSeries1;
        /**
          * Title of the QueryViewer
         */
        "queryTitle": string;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse": QueryViewerServiceResponse;
        /**
          * if true show values on the graph
         */
        "showValues": boolean;
        /**
          * For translate the labels of the outputs
         */
        "translations": QueryViewerTranslations1;
        /**
          * if true the x Axes intersect at zero
         */
        "xAxisIntersectionAtZero": boolean;
        /**
          * Labels for XAxis
         */
        "xAxisLabels": QueryViewerXAxisLabels1;
        /**
          * Y Axis title
         */
        "yAxisTitle": string;
    }
    interface GxQueryViewerController {
        /**
          * @todo Add description
         */
        "allowElementsOrderChange": boolean;
        /**
          * Determines the application namespace where the program is generated and compiled.
         */
        "applicationNamespace": string;
        /**
          * Base URL of the server
         */
        "baseUrl": string;
        /**
          * When `type == Chart`, specifies the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType": QueryViewerChartType;
        /**
          * Environment of the project: java or net
         */
        "environment": GeneratorType;
        /**
          * Include spark line
         */
        "includeSparkline": boolean;
        /**
          * If true includes trend on the graph
         */
        "includeTrend": boolean;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName": string;
        /**
          * Name of the Query or Data provider assigned
         */
        "objectName": string;
        /**
          * Specified the orientation when have more than one card
         */
        "orientation": QueryViewerOrientation;
        /**
          * For timeline for remembering layout
         */
        "rememberLayout": boolean;
        /**
          * @todo Add description
         */
        "returnSampleData": boolean;
        /**
          * Use this property to pass a query obtained from GXquery, when useGxquery = true (ignored if objectName is specified, because this property has a greater precedence)
         */
        "serializedObject": string;
        /**
          * @todo Add description and improve type
         */
        "translationType": string;
        /**
          * Type of the QueryViewer: Table, PivotTable, Chart, Card
         */
        "type": QueryViewerOutputType;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery": boolean;
    }
    interface GxQueryViewerElement {
        /**
          * Aggregation fucntion
         */
        "aggregation": "Sum" | "Average" | "Count" | "Max" | "Min";
        /**
          * Which axis, row or column
         */
        "axis": "Rows" | "Columns" | "Pages";
        /**
          * Axis Order type
         */
        "axisOrderType": | "None"
    | "Ascending"
    | "Descending"
    | "Custom";
        /**
          * Axis order values comma separated
         */
        "axisOrderValues": string;
        /**
          * Data field
         */
        "dataField": string;
        /**
          * Title to show
         */
        "elementTitle": string;
        /**
          * Expand collapse type
         */
        "expandCollapseType": | "ExpandAllValues"
    | "CollapseAllValues"
    | "ExpandSomeValues";
        /**
          * Expand collapse values comma separated
         */
        "expandCollapseValues": string;
        /**
          * Type of the filter
         */
        "filterType": | "ShowAllValues"
    | "HideAllValues"
    | "ShowSomeValues";
        /**
          * Filter values comma separated
         */
        "filterValues": string;
        /**
          * Grouping by day of week title
         */
        "groupingDayOfWeekTitle": string;
        /**
          * Grouping by day of week
         */
        "groupingGroupByDayOfWeek": boolean;
        /**
          * Grouping by month
         */
        "groupingGroupByMonth": boolean;
        /**
          * Grouping by Quarter
         */
        "groupingGroupByQuarter": boolean;
        /**
          * Grouping by semester
         */
        "groupingGroupBySemester": boolean;
        /**
          * Grouping by year
         */
        "groupingGroupByYear": boolean;
        /**
          * Grouping hide vale
         */
        "groupingHideValue": boolean;
        /**
          * Grouping by month title
         */
        "groupingMonthTitle": string;
        /**
          * Grouping by Quarter title
         */
        "groupingQuarterTitle": string;
        /**
          * Grouping by Semster title
         */
        "groupingSemesterTitle": string;
        /**
          * Gouping by Year title
         */
        "groupingYearTitle": string;
        /**
          * Name of the element
         */
        "name": string;
        /**
          * Raise item click
         */
        "raiseItemClick": boolean;
        /**
          * Type of the element
         */
        "type": "Axis" | "Datum";
        /**
          * How to show it
         */
        "visible": "Always" | "Yes" | "No" | "Never";
    }
    interface GxQueryViewerElementFormat {
        /**
          * If true cand drag to pages
         */
        "canDragToPages": boolean;
        /**
          * Format style
         */
        "formatStyle": string;
        /**
          * Max value
         */
        "maximumValue": string;
        /**
          * Format on values
         */
        "picture": string;
        /**
          * How to show subtotals
         */
        "subtotals": "Yes" | "Hidden" | "No";
        /**
          * Target value
         */
        "targetValue": string;
    }
    interface GxQueryViewerFormatStyle {
        /**
          * If Conditional true for applying to row or column
         */
        "applyToRowOrColumn": boolean;
        /**
          * If Format the operator of the element
         */
        "operator": "EQ" | "LT" | "GT" | "LE" | "GE" | "NE" | "IN";
        /**
          * Style or Css class
         */
        "styleOrClass": string;
        /**
          * Type of the element Conditional or Format
         */
        "type": "Values" | "Conditional";
        /**
          * If Conditional Value to format
         */
        "value": string;
        /**
          * If format first value
         */
        "value1": string;
        /**
          * If format second value
         */
        "value2": string;
    }
    interface GxQueryViewerParameter {
        /**
          * Name of the parameter
         */
        "Name": string;
        /**
          * Value of the parameter
         */
        "Value": string;
    }
    interface GxQueryViewerSlider {
        /**
          * This property determines the value of the end position slider.
         */
        "endSliderValue": number;
        /**
          * This property determines the value of the start position slider.
         */
        "startSliderValue": number;
        /**
          * This attribute lets you define the steps for each slider.
         */
        "step": number;
    }
    interface GxSidebar {
        /**
          * Label for collapse button
         */
        "collapseLabel": string;
        /**
          * Width of expanded window. Default 300px
         */
        "collapsedSize": "40px";
        /**
          * Determines if the sidebar can be collapsed
         */
        "collapsible": true;
        /**
          * Determines if should display the actions controls
         */
        "controls": true;
        /**
          * Label for expand button
         */
        "expandLabel": string;
        /**
          * Width of expanded window. Default 300px
         */
        "expandedSize": "300px";
        /**
          * Determines if the sidebar is collapsed
         */
        "isCollapsed": boolean;
        /**
          * Label for expand button
         */
        "newChatLabel": string;
    }
}
export interface GxQueryChatCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryChatElement;
}
export interface GxQueryMenuCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryMenuElement;
}
export interface GxQueryMenuItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryMenuItemElement;
}
export interface GxQueryViewerCardCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerCardElement;
}
export interface GxQueryViewerControllerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerControllerElement;
}
export interface GxQueryViewerElementCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerElementElement;
}
export interface GxQueryViewerElementFormatCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerElementFormatElement;
}
export interface GxQueryViewerFormatStyleCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerFormatStyleElement;
}
export interface GxQueryViewerParameterCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerParameterElement;
}
export interface GxQueryViewerSliderCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxQueryViewerSliderElement;
}
export interface GxSidebarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLGxSidebarElement;
}
declare global {
    interface HTMLGxFloatingWindowElement extends Components.GxFloatingWindow, HTMLStencilElement {
    }
    var HTMLGxFloatingWindowElement: {
        prototype: HTMLGxFloatingWindowElement;
        new (): HTMLGxFloatingWindowElement;
    };
    interface HTMLGxQueryChatElement extends Components.GxQueryChat, HTMLStencilElement {
    }
    var HTMLGxQueryChatElement: {
        prototype: HTMLGxQueryChatElement;
        new (): HTMLGxQueryChatElement;
    };
    interface HTMLGxQueryMenuElement extends Components.GxQueryMenu, HTMLStencilElement {
    }
    var HTMLGxQueryMenuElement: {
        prototype: HTMLGxQueryMenuElement;
        new (): HTMLGxQueryMenuElement;
    };
    interface HTMLGxQueryMenuItemElement extends Components.GxQueryMenuItem, HTMLStencilElement {
    }
    var HTMLGxQueryMenuItemElement: {
        prototype: HTMLGxQueryMenuItemElement;
        new (): HTMLGxQueryMenuItemElement;
    };
    interface HTMLGxQueryRenderElement extends Components.GxQueryRender, HTMLStencilElement {
    }
    var HTMLGxQueryRenderElement: {
        prototype: HTMLGxQueryRenderElement;
        new (): HTMLGxQueryRenderElement;
    };
    interface HTMLGxQueryViewerElement extends Components.GxQueryViewer, HTMLStencilElement {
    }
    var HTMLGxQueryViewerElement: {
        prototype: HTMLGxQueryViewerElement;
        new (): HTMLGxQueryViewerElement;
    };
    interface HTMLGxQueryViewerCardElement extends Components.GxQueryViewerCard, HTMLStencilElement {
    }
    var HTMLGxQueryViewerCardElement: {
        prototype: HTMLGxQueryViewerCardElement;
        new (): HTMLGxQueryViewerCardElement;
    };
    interface HTMLGxQueryViewerCardControllerElement extends Components.GxQueryViewerCardController, HTMLStencilElement {
    }
    var HTMLGxQueryViewerCardControllerElement: {
        prototype: HTMLGxQueryViewerCardControllerElement;
        new (): HTMLGxQueryViewerCardControllerElement;
    };
    interface HTMLGxQueryViewerChartElement extends Components.GxQueryViewerChart, HTMLStencilElement {
    }
    var HTMLGxQueryViewerChartElement: {
        prototype: HTMLGxQueryViewerChartElement;
        new (): HTMLGxQueryViewerChartElement;
    };
    interface HTMLGxQueryViewerChartControllerElement extends Components.GxQueryViewerChartController, HTMLStencilElement {
    }
    var HTMLGxQueryViewerChartControllerElement: {
        prototype: HTMLGxQueryViewerChartControllerElement;
        new (): HTMLGxQueryViewerChartControllerElement;
    };
    interface HTMLGxQueryViewerControllerElement extends Components.GxQueryViewerController, HTMLStencilElement {
    }
    var HTMLGxQueryViewerControllerElement: {
        prototype: HTMLGxQueryViewerControllerElement;
        new (): HTMLGxQueryViewerControllerElement;
    };
    interface HTMLGxQueryViewerElementElement extends Components.GxQueryViewerElement, HTMLStencilElement {
    }
    var HTMLGxQueryViewerElementElement: {
        prototype: HTMLGxQueryViewerElementElement;
        new (): HTMLGxQueryViewerElementElement;
    };
    interface HTMLGxQueryViewerElementFormatElement extends Components.GxQueryViewerElementFormat, HTMLStencilElement {
    }
    var HTMLGxQueryViewerElementFormatElement: {
        prototype: HTMLGxQueryViewerElementFormatElement;
        new (): HTMLGxQueryViewerElementFormatElement;
    };
    interface HTMLGxQueryViewerFormatStyleElement extends Components.GxQueryViewerFormatStyle, HTMLStencilElement {
    }
    var HTMLGxQueryViewerFormatStyleElement: {
        prototype: HTMLGxQueryViewerFormatStyleElement;
        new (): HTMLGxQueryViewerFormatStyleElement;
    };
    interface HTMLGxQueryViewerParameterElement extends Components.GxQueryViewerParameter, HTMLStencilElement {
    }
    var HTMLGxQueryViewerParameterElement: {
        prototype: HTMLGxQueryViewerParameterElement;
        new (): HTMLGxQueryViewerParameterElement;
    };
    interface HTMLGxQueryViewerSliderElement extends Components.GxQueryViewerSlider, HTMLStencilElement {
    }
    var HTMLGxQueryViewerSliderElement: {
        prototype: HTMLGxQueryViewerSliderElement;
        new (): HTMLGxQueryViewerSliderElement;
    };
    interface HTMLGxSidebarElement extends Components.GxSidebar, HTMLStencilElement {
    }
    var HTMLGxSidebarElement: {
        prototype: HTMLGxSidebarElement;
        new (): HTMLGxSidebarElement;
    };
    interface HTMLElementTagNameMap {
        "gx-floating-window": HTMLGxFloatingWindowElement;
        "gx-query-chat": HTMLGxQueryChatElement;
        "gx-query-menu": HTMLGxQueryMenuElement;
        "gx-query-menu-item": HTMLGxQueryMenuItemElement;
        "gx-query-render": HTMLGxQueryRenderElement;
        "gx-query-viewer": HTMLGxQueryViewerElement;
        "gx-query-viewer-card": HTMLGxQueryViewerCardElement;
        "gx-query-viewer-card-controller": HTMLGxQueryViewerCardControllerElement;
        "gx-query-viewer-chart": HTMLGxQueryViewerChartElement;
        "gx-query-viewer-chart-controller": HTMLGxQueryViewerChartControllerElement;
        "gx-query-viewer-controller": HTMLGxQueryViewerControllerElement;
        "gx-query-viewer-element": HTMLGxQueryViewerElementElement;
        "gx-query-viewer-element-format": HTMLGxQueryViewerElementFormatElement;
        "gx-query-viewer-format-style": HTMLGxQueryViewerFormatStyleElement;
        "gx-query-viewer-parameter": HTMLGxQueryViewerParameterElement;
        "gx-query-viewer-slider": HTMLGxQueryViewerSliderElement;
        "gx-sidebar": HTMLGxSidebarElement;
    }
}
declare namespace LocalJSX {
    interface GxFloatingWindow {
        /**
          * Width of expanded window. Default 300px
         */
        "expandedSize"?: "300px";
        /**
          * Determines if the menu is minimized
         */
        "isMinimized"?: boolean;
        /**
          * Determines if the menu is unlocked
         */
        "isUnlocked"?: boolean;
        /**
          * This property specifies the items of the chat.
         */
        "mainTitle"?: string;
        /**
          * Determines if the menu can be unlocked or minimize
         */
        "resizeWindow"?: boolean;
    }
    interface GxQueryChat {
        /**
          * Specify the size of the icon messages. ex 50px
         */
        "messageIconSize"?: string;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName"?: "";
        /**
          * Fired when receive a question answer
         */
        "onGxAssistantResponse"?: (event: GxQueryChatCustomEvent<QueryViewerBase>) => void;
        /**
          * Fired each time the user make a question
         */
        "onGxUserRequest"?: (event: GxQueryChatCustomEvent<QueryRequest>) => void;
        /**
          * Text that appears in the input control when it has no value set
         */
        "placeholder"?: string;
    }
    interface GxQueryMenu {
        /**
          * Specifies a short string, typically 1 to 3 words, that authors associate with an element to provide users of assistive technologies with a label for the element.
         */
        "accessibleName"?: "Query list";
        /**
          * Base URL of the server
         */
        "baseUrl"?: string;
        /**
          * Show queries items group by month
         */
        "groupItemsByMonth"?: true;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName"?: string;
        /**
          * Delete query
         */
        "onGxQueryDelete"?: (event: GxQueryMenuCustomEvent<GxQueryItem>) => void;
        /**
          * Rename query
         */
        "onGxQueryRename"?: (event: GxQueryMenuCustomEvent<GxQueryItem>) => void;
        /**
          * Select a query
         */
        "onGxQuerySelect"?: (event: GxQueryMenuCustomEvent<GxQueryItem>) => void;
        /**
          * Dates to group queries
         */
        "rangeOfDays"?: { days: number; label: string }[];
        /**
          * Use this property to pass a query obtained from GXquery. This disabled the call to GxQuery API:    Id: string;    Name: string;    Description: string;    Expression: string;    Modified: string;
         */
        "serializedObject"?: string;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery"?: true;
    }
    interface GxQueryMenuItem {
        /**
          * Toggle edit mode
         */
        "editMode"?: boolean;
        /**
          * Id of item active
         */
        "isActive"?: boolean;
        /**
          * This property specify the title of the item.
         */
        "item"?: GxQueryItem1;
        /**
          * Trigger the action to delete the item
         */
        "onDeleteItem"?: (event: GxQueryMenuItemCustomEvent<GxQueryItem1>) => void;
        /**
          * Trigger the action to delete the item
         */
        "onRenameItem"?: (event: GxQueryMenuItemCustomEvent<GxQueryItem1>) => void;
        /**
          * Trigger the action to select an item
         */
        "onSelectItem"?: (event: GxQueryMenuItemCustomEvent<GxQueryItem1>) => void;
    }
    interface GxQueryRender {
        /**
          * Base URL of the server
         */
        "baseUrl"?: string;
        /**
          * Data for query viewer
         */
        "data"?: QueryViewerServiceData | string;
        /**
          * Environment of the project: java or net
         */
        "environment"?: GeneratorType;
        "fetchingDataLabel"?: "Fetching data";
        /**
          * Metadata for query viewer
         */
        "metadata"?: QueryViewerServiceMetaData | string;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName"?: string;
        "noDataLabel"?: "No Data";
        /**
          * Provide the Query properties
         */
        "query"?: QueryViewerBase;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery"?: true;
    }
    interface GxQueryViewer {
        /**
          * Allowing elements order to change
         */
        "allowElementsOrderChange"?: boolean;
        /**
          * Allow selection
         */
        "allowSelection"?: boolean;
        /**
          * Auto refresh group
         */
        "autoRefreshGroup"?: string;
        /**
          * If type== PivotTable or Table, if true will shrink the table
         */
        "autoResize"?: boolean;
        /**
          * If autoResize, in here select the type, Width, height, or both
         */
        "autoResizeType"?: "Both" | "Vertical" | "Horizontal";
        /**
          * If type == Chart, this is the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType"?: QueryViewerChartType;
        /**
          * If type == Map and region = Continent, this is the continent to display in the map
         */
        "continent"?: QueryViewerContinent;
        /**
          * If type == Map and region = Country, this is the country to display in the map
         */
        "country"?: QueryViewerCountry;
        /**
          * A CSS class to set as the `gx-query-viewer` element class.
         */
        "cssClass"?: string;
        /**
          * Version of data
         */
        "dataVersionId"?: number;
        /**
          * Allowing or not Column sort
         */
        "disableColumnSort"?: boolean;
        /**
          * If type== PivotTable or Table allow to export to HTML
         */
        "exportToHTML"?: boolean;
        /**
          * If type== PivotTable or Table allow to export to PDF
         */
        "exportToPDF"?: boolean;
        /**
          * If type== PivotTable or Table allow to export to XLS
         */
        "exportToXLS"?: boolean;
        /**
          * If type== PivotTable or Table allow to export to XLSX
         */
        "exportToXLSX"?: boolean;
        /**
          * If type== PivotTable or Table allow to export to XML
         */
        "exportToXML"?: boolean;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin"?: boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline"?: boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend"?: boolean;
        /**
          * Language of the QueryViewer
         */
        "language"?: string;
        /**
          * If type == Map, this is the map type: Choropleth or Bubble
         */
        "mapType"?: QueryViewerMapType;
        /**
          * Object of QueryViewer
         */
        "object"?: string;
        /**
          * Object type -> Query or DataProvider
         */
        "objectType"?: string;
        /**
          * Orientation of the graph
         */
        "orientation"?: QueryViewerOrientation;
        /**
          * If paging true, number of items for a single page
         */
        "pageSize"?: number;
        /**
          * If type == PivotTable or Table, if true there is paging, else everything in one table
         */
        "paging"?: boolean;
        /**
          * Timeline
         */
        "plotSeries"?: QueryViewerPlotSeries;
        /**
          * Title of the QueryViewer
         */
        "queryTitle"?: string;
        /**
          * If type == Map, this is the region to display in the map
         */
        "region"?: QueryViewerRegion;
        /**
          * For timeline for remembering layout
         */
        "rememberLayout"?: boolean;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse"?: QueryViewerServiceResponse;
        /**
          * Specifies whether to show the actual values, the values as a percentage of the target values, or both.
         */
        "showDataAs"?: QueryViewerShowDataAs;
        /**
          * Ax to show data labels
         */
        "showDataLabelsIn"?: QueryViewerShowDataLabelsIn;
        /**
          * if true show values on the graph
         */
        "showValues"?: boolean;
        /**
          * Theme for showing the graph
         */
        "theme"?: string;
        /**
          * True if grand total is shown for all table columns
         */
        "totalForColumns"?: QueryViewerTotal;
        /**
          * True if grand total is shown for all table rows
         */
        "totalForRows"?: QueryViewerTotal;
        /**
          * For translate the labels of the outputs
         */
        "translations"?: QueryViewerTranslations;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod"?: QueryViewerTrendPeriod;
        /**
          * Type of the QueryViewer: Table, PivotTable, Chart, Card
         */
        "type"?: QueryViewerOutputType;
        /**
          * if true the x Axes intersect at zero
         */
        "xAxisIntersectionAtZero"?: boolean;
        /**
          * Labels for XAxis
         */
        "xAxisLabels"?: QueryViewerXAxisLabels;
        /**
          * X Axis title
         */
        "xAxisTitle"?: string;
        /**
          * Y Axis title
         */
        "yAxisTitle"?: string;
    }
    interface GxQueryViewerCard {
        /**
          * Describe the content or purpose of the element set as Datum in the query object.
         */
        "description"?: string;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin"?: boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline"?: boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend"?: boolean;
        /**
          * Specifies the maximum value in the series.
         */
        "maxValue"?: string;
        /**
          * Specifies the minimum value in the series.
         */
        "minValue"?: string;
        /**
          * ItemClickEvent, executes actions when this event is triggered after clicking on a query element.
         */
        "onItemClickEvent"?: (event: GxQueryViewerCardCustomEvent<any>) => void;
        /**
          * Specifies the data used for the series of the sparkline.
         */
        "seriesData"?: number[][];
        /**
          * For translate the labels of the outputs
         */
        "translations"?: QueryViewerTranslations1;
        /**
          * Specifies the icon used for the trend.
         */
        "trendIcon"?: TrendIcon;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod"?: QueryViewerTrendPeriod1;
        /**
          * Specifies the value to show in the card.
         */
        "value"?: string;
    }
    interface GxQueryViewerCardController {
        /**
          * A CSS class to set as the `gx-query-viewer-card-controller` element class.
         */
        "cssClass"?: string;
        /**
          * Specifies whether to include the maximum and minimum values in the series.
         */
        "includeMaxMin"?: boolean;
        /**
          * Specifies whether to include a sparkline chart for the values or not.
         */
        "includeSparkline"?: boolean;
        /**
          * Specifies whether to include a trend mark for the values or not.
         */
        "includeTrend"?: boolean;
        /**
          * Specifies whether to arrange the attributes horizontally or vertically when than one data attribute is present.
         */
        "orientation"?: QueryViewerOrientation1;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse"?: QueryViewerServiceResponse;
        /**
          * Specifies whether to show the actual values, the values as a percentage of the target values, or both.
         */
        "showDataAs"?: QueryViewerShowDataAs1;
        /**
          * For translate the labels of the outputs
         */
        "translations"?: QueryViewerTranslations1;
        /**
          * If `includeTrend == true`, this attribute specifies the period of time to calculate the trend.
         */
        "trendPeriod"?: QueryViewerTrendPeriod1;
    }
    interface GxQueryViewerChart {
        /**
          * Title that will be displayed on top of the query
         */
        "chartOptions"?: ChartOptions;
        /**
          * Name of the element
         */
        "chartTitle"?: TitleOptions;
        /**
          * Option of the chartType used to visualize and represent data.
         */
        "chartType"?: QueryViewerChartType1;
        /**
          * Options of the tooltip, the tooltip appears when hovering over a point in a series.
         */
        "legendOptions"?: LegendOptions;
        /**
          * Options of the chart.
         */
        "paneOptions"?: PaneOptions;
        /**
          * Options of the legend, the legend displays the series in a chart with a predefined symbol and the name of the series.
         */
        "plotOptions"?: PlotOptions;
        /**
          * Specifies if the chart series are plotted together in the same chart or alone in separate charts.
         */
        "plotSeries"?: QueryViewerPlotSeries1;
        /**
          * Options of the X axis (usually this is the horizontal axis).
         */
        "seriesOptions"?: SeriesOptionsType[];
        /**
          * Specifies whether the values for the data elements are shown in the chart or not.
         */
        "showValues"?: boolean;
        /**
          * Name of the element
         */
        "subtitleOptions"?: SubtitleOptions;
        /**
          * Options of the chart.
         */
        "tooltipOptions"?: TooltipOptions;
        /**
          * For translate the labels of the outputs
         */
        "translations"?: QueryViewerTranslations1;
        /**
          * Specifies whether the X axis intersects the Y axis at zero or the intersection point is automatically calculated.
         */
        "xAxisIntersectionAtZero"?: boolean;
        /**
          * Specifies if the labels in the X axis of a chart are shown horizontally or vertically.
         */
        "xAxisLabels"?: QueryViewerXAxisLabels1;
        /**
          * X axis title, if specified.
         */
        "xAxisTitle"?: string;
        /**
          * Options of the Y axis (usually this is the vertical axis).
         */
        "xaxisOptions"?: XAxisOptions | XAxisOptions[];
        /**
          * Y axis title, if specified.
         */
        "yAxisTitle"?: string;
        /**
          * Options of the plot for each series type chart.
         */
        "yaxisOptions"?: YAxisOptions | YAxisOptions[];
    }
    interface GxQueryViewerChartController {
        /**
          * Allow selection
         */
        "allowSelection"?: boolean;
        /**
          * If type == Chart, this is the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType"?: QueryViewerChartType1;
        /**
          * A CSS class to set as the `gx-query-viewer-chart-controller` element class.
         */
        "cssClass"?: string;
        /**
          * Timeline
         */
        "plotSeries"?: QueryViewerPlotSeries1;
        /**
          * Title of the QueryViewer
         */
        "queryTitle"?: string;
        /**
          * Specifies the metadata and data that the control will use to render.
         */
        "serviceResponse"?: QueryViewerServiceResponse;
        /**
          * if true show values on the graph
         */
        "showValues"?: boolean;
        /**
          * For translate the labels of the outputs
         */
        "translations"?: QueryViewerTranslations1;
        /**
          * if true the x Axes intersect at zero
         */
        "xAxisIntersectionAtZero"?: boolean;
        /**
          * Labels for XAxis
         */
        "xAxisLabels"?: QueryViewerXAxisLabels1;
        /**
          * Y Axis title
         */
        "yAxisTitle"?: string;
    }
    interface GxQueryViewerController {
        /**
          * @todo Add description
         */
        "allowElementsOrderChange"?: boolean;
        /**
          * Determines the application namespace where the program is generated and compiled.
         */
        "applicationNamespace"?: string;
        /**
          * Base URL of the server
         */
        "baseUrl"?: string;
        /**
          * When `type == Chart`, specifies the chart type: Bar, Pie, Timeline, etc...
         */
        "chartType"?: QueryViewerChartType;
        /**
          * Environment of the project: java or net
         */
        "environment"?: GeneratorType;
        /**
          * Include spark line
         */
        "includeSparkline"?: boolean;
        /**
          * If true includes trend on the graph
         */
        "includeTrend"?: boolean;
        /**
          * This is the name of the metadata (all the queries belong to a certain metadata) the connector will use when useGxquery = true. In this case the connector must be told the query to execute, either by name (via the objectName property) or giving a full serialized query (via the query property)
         */
        "metadataName"?: string;
        /**
          * Name of the Query or Data provider assigned
         */
        "objectName"?: string;
        /**
          * Fired when new metadata and data is fetched
         */
        "onQueryViewerServiceResponse"?: (event: GxQueryViewerControllerCustomEvent<QueryViewerServiceResponse>) => void;
        /**
          * Specified the orientation when have more than one card
         */
        "orientation"?: QueryViewerOrientation;
        /**
          * For timeline for remembering layout
         */
        "rememberLayout"?: boolean;
        /**
          * @todo Add description
         */
        "returnSampleData"?: boolean;
        /**
          * Use this property to pass a query obtained from GXquery, when useGxquery = true (ignored if objectName is specified, because this property has a greater precedence)
         */
        "serializedObject"?: string;
        /**
          * @todo Add description and improve type
         */
        "translationType"?: string;
        /**
          * Type of the QueryViewer: Table, PivotTable, Chart, Card
         */
        "type"?: QueryViewerOutputType;
        /**
          * True to tell the controller to connect use GXquery as a queries repository
         */
        "useGxquery"?: boolean;
    }
    interface GxQueryViewerElement {
        /**
          * Aggregation fucntion
         */
        "aggregation"?: "Sum" | "Average" | "Count" | "Max" | "Min";
        /**
          * Which axis, row or column
         */
        "axis"?: "Rows" | "Columns" | "Pages";
        /**
          * Axis Order type
         */
        "axisOrderType"?: | "None"
    | "Ascending"
    | "Descending"
    | "Custom";
        /**
          * Axis order values comma separated
         */
        "axisOrderValues"?: string;
        /**
          * Data field
         */
        "dataField"?: string;
        /**
          * Title to show
         */
        "elementTitle"?: string;
        /**
          * Expand collapse type
         */
        "expandCollapseType"?: | "ExpandAllValues"
    | "CollapseAllValues"
    | "ExpandSomeValues";
        /**
          * Expand collapse values comma separated
         */
        "expandCollapseValues"?: string;
        /**
          * Type of the filter
         */
        "filterType"?: | "ShowAllValues"
    | "HideAllValues"
    | "ShowSomeValues";
        /**
          * Filter values comma separated
         */
        "filterValues"?: string;
        /**
          * Grouping by day of week title
         */
        "groupingDayOfWeekTitle"?: string;
        /**
          * Grouping by day of week
         */
        "groupingGroupByDayOfWeek"?: boolean;
        /**
          * Grouping by month
         */
        "groupingGroupByMonth"?: boolean;
        /**
          * Grouping by Quarter
         */
        "groupingGroupByQuarter"?: boolean;
        /**
          * Grouping by semester
         */
        "groupingGroupBySemester"?: boolean;
        /**
          * Grouping by year
         */
        "groupingGroupByYear"?: boolean;
        /**
          * Grouping hide vale
         */
        "groupingHideValue"?: boolean;
        /**
          * Grouping by month title
         */
        "groupingMonthTitle"?: string;
        /**
          * Grouping by Quarter title
         */
        "groupingQuarterTitle"?: string;
        /**
          * Grouping by Semster title
         */
        "groupingSemesterTitle"?: string;
        /**
          * Gouping by Year title
         */
        "groupingYearTitle"?: string;
        /**
          * Name of the element
         */
        "name"?: string;
        /**
          * Fired each time the properties of the control changes
         */
        "onElementChanged"?: (event: GxQueryViewerElementCustomEvent<any>) => void;
        /**
          * Raise item click
         */
        "raiseItemClick"?: boolean;
        /**
          * Type of the element
         */
        "type"?: "Axis" | "Datum";
        /**
          * How to show it
         */
        "visible"?: "Always" | "Yes" | "No" | "Never";
    }
    interface GxQueryViewerElementFormat {
        /**
          * If true cand drag to pages
         */
        "canDragToPages"?: boolean;
        /**
          * Format style
         */
        "formatStyle"?: string;
        /**
          * Max value
         */
        "maximumValue"?: string;
        /**
          * Fired each time the properties of the control changes
         */
        "onElementChanged"?: (event: GxQueryViewerElementFormatCustomEvent<any>) => void;
        /**
          * Format on values
         */
        "picture"?: string;
        /**
          * How to show subtotals
         */
        "subtotals"?: "Yes" | "Hidden" | "No";
        /**
          * Target value
         */
        "targetValue"?: string;
    }
    interface GxQueryViewerFormatStyle {
        /**
          * If Conditional true for applying to row or column
         */
        "applyToRowOrColumn"?: boolean;
        /**
          * Fired each time the properties of the control changes
         */
        "onElementChanged"?: (event: GxQueryViewerFormatStyleCustomEvent<any>) => void;
        /**
          * If Format the operator of the element
         */
        "operator"?: "EQ" | "LT" | "GT" | "LE" | "GE" | "NE" | "IN";
        /**
          * Style or Css class
         */
        "styleOrClass"?: string;
        /**
          * Type of the element Conditional or Format
         */
        "type"?: "Values" | "Conditional";
        /**
          * If Conditional Value to format
         */
        "value"?: string;
        /**
          * If format first value
         */
        "value1"?: string;
        /**
          * If format second value
         */
        "value2"?: string;
    }
    interface GxQueryViewerParameter {
        /**
          * Name of the parameter
         */
        "Name"?: string;
        /**
          * Value of the parameter
         */
        "Value"?: string;
        /**
          * Fired each time the value of the control changes
         */
        "onParameterValueChanged"?: (event: GxQueryViewerParameterCustomEvent<QueryViewerParameterChangedEvent>) => void;
    }
    interface GxQueryViewerSlider {
        /**
          * This property determines the value of the end position slider.
         */
        "endSliderValue"?: number;
        /**
          * Fired when a new range of the control is committed by the user.
         */
        "onChange"?: (event: GxQueryViewerSliderCustomEvent<QueryViewerSliderRange>) => void;
        /**
          * This property determines the value of the start position slider.
         */
        "startSliderValue"?: number;
        /**
          * This attribute lets you define the steps for each slider.
         */
        "step"?: number;
    }
    interface GxSidebar {
        /**
          * Label for collapse button
         */
        "collapseLabel"?: string;
        /**
          * Width of expanded window. Default 300px
         */
        "collapsedSize"?: "40px";
        /**
          * Determines if the sidebar can be collapsed
         */
        "collapsible"?: true;
        /**
          * Determines if should display the actions controls
         */
        "controls"?: true;
        /**
          * Label for expand button
         */
        "expandLabel"?: string;
        /**
          * Width of expanded window. Default 300px
         */
        "expandedSize"?: "300px";
        /**
          * Determines if the sidebar is collapsed
         */
        "isCollapsed"?: boolean;
        /**
          * Label for expand button
         */
        "newChatLabel"?: string;
        /**
          * Crear a new chat
         */
        "onGxQueryNewChat"?: (event: GxSidebarCustomEvent<null>) => void;
    }
    interface IntrinsicElements {
        "gx-floating-window": GxFloatingWindow;
        "gx-query-chat": GxQueryChat;
        "gx-query-menu": GxQueryMenu;
        "gx-query-menu-item": GxQueryMenuItem;
        "gx-query-render": GxQueryRender;
        "gx-query-viewer": GxQueryViewer;
        "gx-query-viewer-card": GxQueryViewerCard;
        "gx-query-viewer-card-controller": GxQueryViewerCardController;
        "gx-query-viewer-chart": GxQueryViewerChart;
        "gx-query-viewer-chart-controller": GxQueryViewerChartController;
        "gx-query-viewer-controller": GxQueryViewerController;
        "gx-query-viewer-element": GxQueryViewerElement;
        "gx-query-viewer-element-format": GxQueryViewerElementFormat;
        "gx-query-viewer-format-style": GxQueryViewerFormatStyle;
        "gx-query-viewer-parameter": GxQueryViewerParameter;
        "gx-query-viewer-slider": GxQueryViewerSlider;
        "gx-sidebar": GxSidebar;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "gx-floating-window": LocalJSX.GxFloatingWindow & JSXBase.HTMLAttributes<HTMLGxFloatingWindowElement>;
            "gx-query-chat": LocalJSX.GxQueryChat & JSXBase.HTMLAttributes<HTMLGxQueryChatElement>;
            "gx-query-menu": LocalJSX.GxQueryMenu & JSXBase.HTMLAttributes<HTMLGxQueryMenuElement>;
            "gx-query-menu-item": LocalJSX.GxQueryMenuItem & JSXBase.HTMLAttributes<HTMLGxQueryMenuItemElement>;
            "gx-query-render": LocalJSX.GxQueryRender & JSXBase.HTMLAttributes<HTMLGxQueryRenderElement>;
            "gx-query-viewer": LocalJSX.GxQueryViewer & JSXBase.HTMLAttributes<HTMLGxQueryViewerElement>;
            "gx-query-viewer-card": LocalJSX.GxQueryViewerCard & JSXBase.HTMLAttributes<HTMLGxQueryViewerCardElement>;
            "gx-query-viewer-card-controller": LocalJSX.GxQueryViewerCardController & JSXBase.HTMLAttributes<HTMLGxQueryViewerCardControllerElement>;
            "gx-query-viewer-chart": LocalJSX.GxQueryViewerChart & JSXBase.HTMLAttributes<HTMLGxQueryViewerChartElement>;
            "gx-query-viewer-chart-controller": LocalJSX.GxQueryViewerChartController & JSXBase.HTMLAttributes<HTMLGxQueryViewerChartControllerElement>;
            "gx-query-viewer-controller": LocalJSX.GxQueryViewerController & JSXBase.HTMLAttributes<HTMLGxQueryViewerControllerElement>;
            "gx-query-viewer-element": LocalJSX.GxQueryViewerElement & JSXBase.HTMLAttributes<HTMLGxQueryViewerElementElement>;
            "gx-query-viewer-element-format": LocalJSX.GxQueryViewerElementFormat & JSXBase.HTMLAttributes<HTMLGxQueryViewerElementFormatElement>;
            "gx-query-viewer-format-style": LocalJSX.GxQueryViewerFormatStyle & JSXBase.HTMLAttributes<HTMLGxQueryViewerFormatStyleElement>;
            "gx-query-viewer-parameter": LocalJSX.GxQueryViewerParameter & JSXBase.HTMLAttributes<HTMLGxQueryViewerParameterElement>;
            "gx-query-viewer-slider": LocalJSX.GxQueryViewerSlider & JSXBase.HTMLAttributes<HTMLGxQueryViewerSliderElement>;
            "gx-sidebar": LocalJSX.GxSidebar & JSXBase.HTMLAttributes<HTMLGxSidebarElement>;
        }
    }
}
